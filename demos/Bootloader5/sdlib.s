/*
 *  SD Card interface library
 *  Copyright (C) 2017 Sandor Zsuga (Jubatian)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/



#include <avr/io.h>


.section .text



/*
** Ports and pins
*/
#define SPI_P   _SFR_IO_ADDR(PORTB)
#define SPI_DDR _SFR_IO_ADDR(DDRB)
#define CS_P    _SFR_IO_ADDR(PORTD)
#define CS_DDR  _SFR_IO_ADDR(DDRD)
#define SD_SCK  7
#define SD_MOSI 5
#define SD_MISO 6
#define SD_CS   6

/*
** SPI registers
*/
#define SPI_CR  _SFR_IO_ADDR(SPCR)
#define SPI_DR  _SFR_IO_ADDR(SPDR)
#define SPI_SR  _SFR_IO_ADDR(SPSR)



/*
** SD card access data structure:
**
** uint8  flags;       SD status flags
**                     bit 0: 1 if SD card is detected and initialized
**                     bit 1: Card type: 0: SDSC, 1: SDHC
**                     bit 2: Filesystem type: 0: FAT-16, 1: FAT-32
**                     bit 3: Selected file is the FAT16 root directory if set
** uint8* bufp;        Pointer to 512 byte sector buffer
** uint8  csize;       Cluster size in 512 byte sector units
** uint16 fatp;        Address of FAT in 512 byte sector units
** uint32 datap;       Address of Data in 512 byte sector units
** uint32 rootp;       FAT16: Address of Root directory in 512 byte sectors
**                     FAT32: First cluster of Root directory
** uint32 fclus;       First cluster of currently selected file
** uint32 cclus;       Current cluster of currently selected file
** uint8  csec;        Currect 512 byte sector within current cluster
*/



/*
** Slow (but small: no table) CRC7 calculation for SD Card commands.
**
** Calculation must start with 0x00 CRC value.
**
** The final CRC value for the CRC field must be generated by left shifting
** the result and OR-ing one.
**
** Inputs:
**     r24: CRC value
**     r22: Byte to add to the calculation
** Outputs:
**     r24: Resulting CRC value
** Clobbers:
** r22
*/
.global SD_CRC7_Byte
SD_CRC7_Byte:

	lsl   r24
	eor   r24,     r22     ; crcval  ^= byte
	ldi   r22,     0x89    ; CRC7 polynomial
	sbrc  r24,     7
	eor   r24,     r22
	rcall SD_CRC7_Byte_blk
	rcall SD_CRC7_Byte_blk
	rcall SD_CRC7_Byte_blk
	rcall SD_CRC7_Byte_blk
	rcall SD_CRC7_Byte_blk
	rcall SD_CRC7_Byte_blk

SD_CRC7_Byte_blk:
	lsl   r24
	sbrc  r24,     7
	eor   r24,     r22
	ret



/*
** Slow (but small: no table) CRC16 calculation for SD Card commands.
**
** Calculation must start with 0x0000 CRC value.
**
** The final CRC value is to be used as-is, the card has it in Little Endian
** byte order.
**
** Inputs:
** r25:r24: CRC value
**     r22: Byte to add to the calculation
** Outputs:
** r25:r24: Resulting CRC value
** Clobbers:
** r22, r23
*/
.global SD_CRC16_Byte
SD_CRC16_Byte:

	eor   r25,     r22     ; crcval ^= (byte << 8)
	ldi   r22,     0x21
	ldi   r23,     0x10    ; CRC16 polynomial (0x1021)
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk
	rcall SD_CRC16_Byte_blk

SD_CRC16_Byte_blk:
	lsl   r24
	rol   r25
	brcc  .+4
	eor   r24,     r22
	eor   r25,     r23
	ret



/*
** Releases the SD card appropriately with a trailing 0xFF byte.
**
** Inputs:
** Outputs:
** Clobbers:
** r0
*/
.global SD_Release
SD_Release:

	sbi   CS_P,    SD_CS   ; Chip Select: High
	                       ; Fall through to sdlib_wait_spi_with_FF



/*
** Internal function to send 0xFF byte and wait for completion. Useful for
** reading data.
**
** Clobbers:
** r0
*/
sdlib_wait_spi_with_FF:

	sec
	in    r0,      SPI_SR  ; Make sure SPIF is ready for polling
	sbc   r0,      r0      ; r0 = 0xFF
	out   SPI_DR,  r0      ; Fall through to sdlib_wait_spi



/*
** Internal function to wait for SPI transaction completion.
**
** Clobbers:
** r0
*/
sdlib_wait_spi:

	in    r0,      SPI_SR
	sbrc  r0,      SPIF
	ret
	rjmp  .-8



/*
** Internal function to zero r23:r22:r21:r20.
*/
sdlib_cl_r23_r20:

	ldi   r23,     0
	ldi   r22,     0
	movw  r20,     r22
	ret



/*
** Internal function for SD_Command: Calculate CRC and wait SPI completion.
*/
sdlib_crc7_byte_wait_spi:

	rcall SD_CRC7_Byte
	rjmp  sdlib_wait_spi



/*
** Sends SD command and waits for the first response byte (normally R1).
** Calculates CRC proper, and supports low SPI speeds. Pulls CS low before
** sending the command, and keeps it that way (low).
**
** Inputs:
**     r24: Command byte
** r23:r22: Argument, high
** r21:r20: Argument, low (together they are a proper C uint32)
** Outputs:
**     r24: First response byte (normally R1)
** Clobbers:
** r0, r24, r25
*/
.global SD_Command
SD_Command:

	cbi   CS_P,    SD_CS   ; Chip Select: Low
	andi  r24,     0x3F
	ori   r24,     0x40    ; Form command byte
	rcall sdlib_wait_spi_with_FF
	out   SPI_DR,  r24     ; Send command byte
	push  r22              ; Put aside argument byte 1 to begin CRC calculation
	mov   r22,     r24     ; First byte for CRC7
	ldi   r24,     0       ; Initial CRC7 value
	rcall sdlib_crc7_byte_wait_spi
	out   SPI_DR,  r23     ; Send arg. byte 0
	mov   r22,     r23     ; Argument byte 0 for CRC
	rcall sdlib_crc7_byte_wait_spi
	pop   r22              ; Restore arg. byte 1
	out   SPI_DR,  r22     ; Send arg. byte 1
	rcall sdlib_crc7_byte_wait_spi
	out   SPI_DR,  r21     ; Send arg. byte 2
	mov   r22,     r21     ; Argument byte 2 for CRC
	rcall sdlib_crc7_byte_wait_spi
	out   SPI_DR,  r20     ; Send arg. byte 3
	mov   r22,     r20     ; Argument byte 3 for CRC
	rcall sdlib_crc7_byte_wait_spi
	lsl   r24
	ori   r24,     1       ; Final CRC7 value
	out   SPI_DR,  r24     ; Send CRC
	rcall sdlib_wait_spi
	ldi   r25,     16      ; Wait up to 16 bytes for response
SD_Command_wl:
	rcall sdlib_wait_spi_with_FF
	in    r24,     SPI_DR
	cpi   r24,     0xFF
	brne  SD_Command_ret
	dec   r25
	brne  SD_Command_wl
SD_Command_ret:
	ret



/*
** Waits for the end of a sequence of 0xFF returning the byte breaking the
** sequence. Waits for up to 4096 bytes.
**
** Inputs:
** Outputs:
**     r24: Byte received (0xFF is timed out)
** Clobbers:
** r0, r25
*/
.global SD_Wait_FF
SD_Wait_FF:

	ldi   r24,     0x00
	ldi   r25,     0x10
SD_Wait_FF_l:
	rcall sdlib_wait_spi_with_FF
	in    r0,      SPI_DR
	inc   r0
	brne  SD_Wait_FF_ret
	sbiw  r24,     1
	brne  SD_Wait_FF_l
SD_Wait_FF_ret:
	dec   r0
	mov   r24,     r0
	ret



/*
** Common return blocks
*/
sdlib_ret_okr:
	rcall SD_Release
sdlib_ret_ok:
	ldi   r24,     0x00
sdlib_ret_fl_c:
	ldi   r25,     0x00
sdlib_ret:
	ret
sdlib_ret_fl_01:
	ldi   r24,     0x01
	rjmp  sdlib_ret_fl_c
sdlib_ret_fl_02r:
	rcall SD_Release
sdlib_ret_fl_02:
	ldi   r24,     0x02
	rjmp  sdlib_ret_fl_c
sdlib_ret_fl_03r:
	rcall SD_Release
sdlib_ret_fl_03:
	ldi   r24,     0x03
	rjmp  sdlib_ret_fl_c
sdlib_ret_fl_04r:
	rcall SD_Release
sdlib_ret_fl_04:
	ldi   r24,     0x04
	rjmp  sdlib_ret_fl_c
sdlib_ret_fl_05:
	ldi   r24,     0x05
	rjmp  sdlib_ret_fl_c



/*
** Detects and initializes SD card. This takes a few dozen milliseconds. It
** populates the SD data structure according to the results, which means
** setting the Initialized and SDHC flags. Note that before calling, make sure
** to wait enough for power stabilization (for example by some WaitVsync()
** calls) after a power on event.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
**     r24: Zero if initialization succeeded. Otherwise one of the followings:
**          1: CMD0 failed (possibly no card in socket)
**          2: CMD59 failed (couldn't enable CRC checking)
**          3: ACMD41 failed (not possible to initialize, bad card)
**          4: ACMD41 timed out
**          5: CMD58 failed (couldn't query card)
** Clobbers:
** r0, r18, r19, r20, r21, r22, r23, r24, r25, X, Z
*/
.global SD_Init
SD_Init:

	; Put aside SD data structure in a pointer and set uninitialized

	movw  XL,      r24
	ldi   r25,     0
	st    X,       r25

	; Setup pins. In the bootloader the kernel does this already, but it
	; is necessary to do this for using as an API call where the pins
	; might have not been set up.

	sbi   SPI_P,   SD_MISO ; MISO is weak pull-up

	sbi   SPI_DDR, SD_SCK  ; SD_SCK is an output
	sbi   SPI_DDR, SD_MOSI ; SD_MOSI is an output

	cbi   SPI_P,   SD_SCK  ; SCK is low
	cbi   SPI_P,   SD_MOSI ; MOSI is low

	sbi   CS_P,    SD_CS   ; Initial Chip Select level is high
	sbi   CS_DDR,  SD_CS   ; Direction is output

	; Enable SPI at 1/128 divider (~250KHz at 32MHz)

	ldi   r25,     (1 << MSTR) | (1 << SPE) | (1 << SPR1) | (1 << SPR0)
	out   SPI_CR,  r25
	ldi   r25,     0
	out   SPI_SR,  r25

	; Try transitioning into Idle state 3 times

	ldi   ZL,      3
SD_Init_CMD0l:

	; Send 80 clocks to get card into native mode.

	ldi   r23,     10      ; 80 clocks as 10 * 8 bits
	rcall sdlib_wait_spi_with_FF
	dec   r23
	brne  .-6              ; 10 bytes

	; Send CMD0 trying to get into Idle state

	ldi   r24,     0       ; CMD0
	rcall sdlib_cl_r23_r20 ; Argument: 0x00000000
	rcall SD_Init_CommRel
	cpi   r24,     0x01    ; Return value (R1 response) should be 0x01 (Idle state)
	breq  SD_Init_CMD0l_e
	dec   ZL
	brne  SD_Init_CMD0l
	rjmp  sdlib_ret_fl_01
SD_Init_CMD0l_e:

	; Enable CRC checking

	ldi   r24,     59      ; CMD59
	rcall sdlib_cl_r23_r20
	ldi   r20,     0x01    ; CRC checking ON
	rcall SD_Init_CommRel
	cpi   r24,     0x01    ; R1
	breq  .+2
	rjmp  sdlib_ret_fl_02

	; Send interface condition to enter Verified state. Don't check result
	; (have no much point, init will fail later if wrong, but command is
	; necessary to allow ACMD41).

	ldi   r24,     8       ; CMD8
	rcall sdlib_cl_r23_r20
	ldi   r21,     0x01
	ldi   r20,     0xAA    ; Argument: 0x000001AA
	rcall SD_Init_CommOCRRel
	ldi   ZH,      0x00    ; HCS will be clear id there is no valid response
	cpi   r24,     0x01    ; R1 if any
	brne  .+2
	ldi   ZH,      0x40    ; Prepare HCS bit (High Capacity Supported)

	; Try transitioning into Ready state 256 times at most (should be
	; between 0.5 - 1 sec at most)

	ldi   ZL,      0
SD_Init_ACMDl:

	; Send App Command prefix

	ldi   r24,     55      ; CMD55
	rcall sdlib_cl_r23_r20 ; Argument: 0x00000000
	rcall SD_Init_CommRel

	; Send App Command 41 to leave Idle state

	ldi   r24,     41      ; ACMD41
	rcall sdlib_cl_r23_r20 ; Argument: 0x40000000 (if CMD8 succeeded)
	mov   r23,     ZH      ; HCS bit (as prepared by CMD8 result)
	rcall SD_Init_CommOCRRel
	cpi   r24,     0x01    ; R1 is Idle?
	breq  SD_Init_ACMDl_m  ; Wait some more
	brcs  SD_Init_ACMDl_e  ; R1 is Ready? (0x00)
	rjmp  sdlib_ret_fl_03
SD_Init_ACMDl_m:
	dec   ZL
	brne  SD_Init_ACMDl
	rjmp  sdlib_ret_fl_04
SD_Init_ACMDl_e:

	; Query OCR to get whether it is an SDHC card

	ldi   r24,     58      ; CMD58
	rcall sdlib_cl_r23_r20 ; Argument: 0x00000000
	rcall SD_Init_CommOCRRel
	cpi   r24,     0x00    ; R1 is OK?
	breq  .+2
	rjmp  sdlib_ret_fl_05

	; Card initialized, now bump up SPI speed to ~3.5MHz (not max as due
	; to the CRC calculations, it can not be exploited anyway).

	ldi   r25,     (1 << MSTR) | (1 << SPE) | (1 << SPR0)
	out   SPI_CR,  r25
	ldi   r25,     (1 << SPI2X)
	out   SPI_SR,  r25

	; Set flags in SD structure

	ldi   r25,     0x01    ; Card initialized (bit 0) set
	sbrc  r23,     6       ; OCR bit 30: If set, SDHC
	ori   r25,     0x02    ; SDHC
	st    X,       r25

	; Done

	rjmp  sdlib_ret_ok     ; Success

SD_Init_CommRel:

	rcall SD_Command
	rjmp  SD_Release

SD_Init_CommOCRRel:

	rcall SD_Command
	rcall sdlib_wait_spi_with_FF
	in    r23,     SPI_DR  ; OCR Byte 3
	rcall sdlib_wait_spi_with_FF
	in    r22,     SPI_DR  ; OCR Byte 2
	rcall sdlib_wait_spi_with_FF
	in    r21,     SPI_DR  ; OCR Byte 1
	rcall sdlib_wait_spi_with_FF
	in    r20,     SPI_DR  ; OCR Byte 0
	rjmp  SD_Release



/*
** Performs a single sector read with a retry when the read fails.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** r23:r22: 512b sector address, high
** r21:r20: 512b sector address, low (together they are a proper C uint32)
** Outputs:
**     r24: Zero if operation succeeded. Otherwise one of the followings:
**          1: Card is not initialized
**          2: CMD17 failed
**          3: Timed out during waiting for data token
**          4: CRC error (data is loaded, but possibly corrupt)
** Clobbers:
** r0, r18, r19, r20, r21, r22, r23, r24, r25, X, Z
*/
.global SD_Read_Sector_Rt
SD_Read_Sector_Rt:
	movw  r18,     r20
	movw  XL,      r22
	push  r24
	push  r25
	rcall SD_Read_Sector
	pop   r25
	pop   r0
	movw  r22,     XL
	movw  r20,     r18
	cpi   r24,     0x00
	brne  .+2
	ret                    ; Read successful
	mov   r24,     r0      ; Fall through to SD_Read_Sector



/*
** Performs a single sector read.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** r23:r22: 512b sector address, high
** r21:r20: 512b sector address, low (together they are a proper C uint32)
** Outputs:
**     r24: Zero if operation succeeded. Otherwise one of the followings:
**          1: Card is not initialized
**          2: CMD17 failed
**          3: Timed out during waiting for data token
**          4: CRC error (data is loaded, but possibly corrupt)
** Clobbers:
** r0, r20, r21, r22, r23, r24, r25, Z
*/
.global SD_Read_Sector
SD_Read_Sector:

	; Load parameters

	movw  ZL,      r24
	ld    r25,     Z       ; Flags
	rcall sdlib_get_secbuf_Z

	; Check flags

	sbrc  r25,     1       ; SDSC card?
	rjmp  SD_Read_Sector_fce
	mov   r23,     r22
	mov   r22,     r21
	mov   r21,     r20
	ldi   r20,     0x00
	lsl   r21
	rol   r22
	rol   r23              ; SDSC cards use byte address
SD_Read_Sector_fce:

	; Prepare SD Read block command (CMD17)

	ldi   r24,     17      ; CMD17, parameter is OK in r23:r22:r21:r20
	rcall SD_Command
	cpi   r24,     0x00    ; R1 is Ready?
	breq  .+2
	rjmp  sdlib_ret_fl_02r

	; Wait for Data Token & Check

	rcall SD_Wait_FF
	cpi   r24,     0xFE    ; Data token OK
	breq  .+2
	rjmp  sdlib_ret_fl_03r

	; Data is ready to be read. Do it along with CRC calculation

	ldi   r24,     0x00
	ldi   r25,     0x00    ; CRC value begin
	rcall sdlib_wait_spi_with_FF
	movw  r20,     ZL
	subi  r21,     0xFE    ; End of target (+ 512 bytes); carry set
SD_Read_Sector_l:
	in    r22,     SPI_DR
	sbc   r0,      r0
	out   SPI_DR,  r0
	st    Z+,      r22     ; Store byte
	rcall SD_CRC16_Byte
	rcall sdlib_wait_spi
	cp    ZL,      r20
	cpc   ZH,      r21
	brcs  SD_Read_Sector_l

	; 512 bytes in and calculated CRC upon, read the CRC

	in    r21,     SPI_DR
	rcall sdlib_wait_spi_with_FF
	in    r20,     SPI_DR
	sub   r24,     r20
	sbc   r25,     r21
	breq  .+2
	rjmp  sdlib_ret_fl_04r

	; Done, correct read

	rjmp  sdlib_ret_okr    ; Success



/*
** Internal function to fetch sector buffer from SD data structure
**
** Inputs:
** r11:r10: SD data structure
** Outputs:
** ZH: ZL:  Sector buffer address
** Clobbers:
** r0
*/
sdlib_get_secbuf:
	movw  ZL,      r10
sdlib_get_secbuf_Z:
	ldd   r0,      Z + 1
	ldd   ZH,      Z + 2
	mov   ZL,      r0
	ret



/*
** Internal function to check whether a value is a power of 2
**
** Inputs:
**     r24: Value to check
** Outputs:
**     C:   Set if it is not a power of 2, clear otherwise
** Clobbers:
** r0, r24
*/
sdlib_isnotpow2:
	mov   r0,      r24
	subi  r24,     1       ; C set if zero (indicating not a power of 2)
	and   r24,     r0
	breq  .+2              ; val & (val - 1) must be zero to be a power of 2
sdlib_isfatboot_ok:
	sec
	ret



/*
** Internal function to check whether a sector is a valid FAT boot sector
**
** Inputs:
** r11:r10: Pointer to SD data structure
** Outputs:
**     C:   Set if it could be a valid FAT boot sector
**     r21: Bytes / sector, high (low is zero)
**     r20: Sectors / cluster
** r23:r22: Reserved sectors
**  ZH: ZL: Sector buffer
** Clobbers:
** r0, r24
*/
sdlib_isfatboot:
	rcall sdlib_get_secbuf ; ZH:ZL: SD data structure -> sector buffer
	ldd   r20,     Z + 0x0B
	cpi   r20,     0x00    ; Sector size, low: must be 0
	brne  sdlib_isfatboot_bad
	ldd   r20,     Z + 0x10
	cpi   r20,     0x02    ; Number of FATs: must be 2
	brne  sdlib_isfatboot_bad
	ldd   r21,     Z + 0x0C
	ldd   r20,     Z + 0x0D
	ldd   r22,     Z + 0x0E
	ldd   r23,     Z + 0x0F
	mov   r24,     r21
	rcall sdlib_isnotpow2  ; Sector size, high: must be a power of 2
	brcs  sdlib_isfatboot_bad
	mov   r24,     r20
	rcall sdlib_isnotpow2  ; Sectors / cluster: must be a power of 2
	brcs  sdlib_isfatboot_bad
	cpi   r23,     0x00
	brne  sdlib_isfatboot_ok
	cpi   r22,     0x00    ; Reserved sectors: must not be 0 (16 bits)
	brne  sdlib_isfatboot_ok
sdlib_isfatboot_bad:
	clc
	ret



/*
** Detects and initializes SD card and FAT filesystem over it. This takes a
** few dozen milliseconds. It populates the SD data structure according to the
** results, which means setting the Filesystem type flag in addition to SD
** init.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
**     r24: Zero if initialization succeeded. Otherwise one of the followings:
**          1: SD Init: CMD0 failed (possibly no card in socket)
**          2: SD Init: CMD59 failed (couldn't enable CRC checking)
**          3: SD Init: ACMD41 failed (not possible to initialize, bad card)
**          4: SD Init: ACMD41 timed out
**          5: SD Init: CMD58 failed (couldn't query card)
**          6: SD read fault
**          7: No usable FAT filesystem found
** Clobbers:
** r0, r1 (zero), r18, r19, r20, r21, r22, r23, r24, r25, X, Z
*/
.global FAT_Init
FAT_Init:

	push  r10
	push  r11
	movw  r10,     r24

	; Init SD card (try twice)

	rcall SD_Init
	cpi   r24,     0x00
	breq  FAT_Init_cont
	rcall SD_Init
	cpi   r24,     0x00
	breq  FAT_Init_cont
	rjmp  FAT_Init_ret     ; SD init failed, return failure code

	; Return blocks

FAT_Init_ret_succ:
	clr   r24
	pop   YH
	pop   YL
FAT_Init_ret:
	pop   r11
	pop   r10
	clr   r1
	clr   r25
	ret

FAT_Init_ret_6:
	ldi   r24,     0x06
	rjmp  FAT_Init_ret

FAT_Init_ret_7:
	ldi   r24,     0x07
	rjmp  FAT_Init_ret

FAT_Init_cont:

	; Read sector 0

	movw  r24,     r10
	ldi   r20,     0
	ldi   r21,     0
	movw  r22,     r20
	rcall SD_Read_Sector_Rt
	ldi   XL,      0
	ldi   XH,      0
	cpi   r24,     0x00
	brne  FAT_Init_ret_6   ; Read failed

	; Check whether it is a FAT boot sector

	rcall sdlib_isfatboot
	brcs  FAT_Init_bootok

	; It was likely an MBR. Load partition 0 start

	movw  r24,     r10
	subi  ZL,      0x42
	sbci  ZH,      0xFE    ; Add 0x01B2 (address of Partition 0)
	ldd   r20,     Z + 8
	ldd   r21,     Z + 9   ; Get Partition 0 LBA (assume it is on the beginning somewhere)
	ldi   r22,     0
	ldi   r23,     0
	push  r20
	push  r21
	rcall SD_Read_Sector_Rt
	pop   XH
	pop   XL
	cpi   r24,     0x00
	brne  FAT_Init_ret_6   ; Read failed

	; Check whether it is a FAT boot sector

	rcall sdlib_isfatboot
	brcc  FAT_Init_ret_7   ; No usable FAT filesystem

FAT_Init_bootok:

	; Assume a valid FAT boot sector is found. Get filesystem parameters.
	; The followings are already loaded:
	;     r21: Bytes / sector, high (low is zero)
	;     r20: Sectors / cluster
	; r23:r22: Reserved sectors
	; XH: XL:  Base 512 byte sector

	push  YL
	push  YH
	movw  YL,      r10

	mul   r20,     r21
	lsr   r1
	ror   r0
	std   Y + 3,   r0      ; Cluster size in 512 byte sector units
	mul   r22,     r21
	movw  r24,     r0
	mul   r23,     r21
	add   r25,     r0
	lsr   r25
	ror   r24
	add   XL,      r24
	adc   XH,      r25
	std   Y + 4,   XL
	std   Y + 5,   XH      ; FAT0 address in 512 byte sector units

	; Get FAT size, also switch to FAT32 if it is 0 (indicating this
	; filesystem). FAT0 address in XH:XL is preserved for further relative
	; offsets & FAT32 root directory address (in FAT0).

	ldd   r18,     Z + 0x16
	ldd   r19,     Z + 0x17
	clr   r22
	clr   r23
	ldd   r20,     Y + 0   ; SD data structure -> flags
	andi  r20,     0xFB    ; bit 2 => 0: FAT16
	cpi   r18,     0x00
	brne  FAT_Init_no32
	cpi   r19,     0x00
	brne  FAT_Init_no32

	ori   r20,     0x04    ; bit 2 => 1: FAT32
	ldd   r18,     Z + 0x24
	ldd   r19,     Z + 0x25
	ldd   r22,     Z + 0x26
	ldd   r23,     Z + 0x27

FAT_Init_no32:

	std   Y + 0,   r20     ; SD data structure -> flags
	mul   r18,     r21     ; Calculate FAT size in 512 byte sectors
	movw  r24,     r0
	mul   r19,     r21
	add   r25,     r0
	ldi   r18,     0x00
	adc   r18,     r1
	mul   r22,     r21
	add   r18,     r0
	ldi   r19,     0x00
	adc   r19,     r1
	mul   r23,     r21
	add   r19,     r0      ; r19:r18:25:r24: 2x FAT size in 512 byte sectors
	clr   r1
	add   r24,     XL
	adc   r25,     XH
	adc   r18,     r1
	adc   r19,     r1      ; Data (FAT32) / Root directory (FAT16) address

	; Rest of entries depend on FAT type (FAT16 / FAT32)

	sbrs  r20,     2
	rjmp  FAT_Init_16

	; FAT32 filesystem

	std   Y + 6,   r24
	std   Y + 7,   r25
	std   Y + 8,   r18
	std   Y + 9,   r19     ; Data address in 512 byte sectors

	; Root dir. address (cluster)

	ldd   r22,     Z + 0x2C
	ldd   r23,     Z + 0x2D
	ldd   r24,     Z + 0x2E
	ldd   r25,     Z + 0x2F
	std   Y + 10,  r22
	std   Y + 11,  r23
	std   Y + 12,  r24
	std   Y + 13,  r25     ; Root dir. address in clusters

	; Done, necessary FAT data is all loaded.

	rjmp  FAT_Init_ret_succ

FAT_Init_16:

	; FAT16 filesystem

	std   Y + 10,  r24
	std   Y + 11,  r25
	std   Y + 12,  r18
	std   Y + 13,  r19     ; Root dir. address in 512 byte sectors

	; Get root directory size

	ldd   r20,     Z + 0x11
	ldd   r21,     Z + 0x12

	; Round up to sector boundary and get data start

	subi  r20,     0xF1
	sbci  r21,     0xFF    ; Add 0x000F
	lsr   r21
	ror   r20
	lsr   r21
	ror   r20
	lsr   r21
	ror   r20
	lsr   r21
	ror   r20              ; Divide by 16 (32b units => 512b units)
	add   r24,     r20
	adc   r25,     r21
	adc   r18,     r1      ; (r1 is zero)
	adc   r19,     r1
	std   Y + 6,   r24
	std   Y + 7,   r25
	std   Y + 8,   r18
	std   Y + 9,   r19     ; Data address in 512 byte sectors

	; Done, necessary FAT data is all loaded.

	rjmp  FAT_Init_ret_succ



/*
** Internal function to serve Get_Sector and Read_Sector. Get_Sector which
** outputs the sector address into r23:r22:r21:r20.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
** r23:r22: Current sector, high
** r21:r20: Current sector, low
** Clobbers:
** r0, r1 (zero), r18, r19, Z, X
*/
sdlib_get_sector:

	movw  ZL,      r24
	ldd   r20,     Z + 18  ; Current cluster of file
	ldd   r21,     Z + 19  ; OR FAT16 root dir. current sector
	ldd   r22,     Z + 20
	ldd   r23,     Z + 21

	ldd   r0,      Z + 0   ; If FAT16 root dir. current sector, just read
	sbrc  r0,      3
	rjmp  sdlib_get_sector_root16

	; Convert to sector address

	subi  r20,     2       ; Cluster base is 2 (maps to address 0 in data)
	sbci  r21,     0
	sbci  r22,     0
	sbci  r23,     0
	ldd   XH,      Z + 3   ; Cluster size in 512 byte sectors

	mul   r20,     XH
	movw  r18,     r0
	ldi   r24,     0
	ldi   r25,     0
	mul   r21,     XH
	add   r19,     r0
	adc   r24,     r1
	mul   r22,     XH
	add   r24,     r0
	adc   r25,     r1
	mul   r23,     XH
	add   r25,     r0      ; Sector address within Data in r25:r24:r19:r18
	clr   r1

	ldd   r20,     Z + 6
	add   r20,     r18
	ldd   r21,     Z + 7
	adc   r21,     r19
	ldd   r22,     Z + 8
	adc   r22,     r24
	ldd   r23,     Z + 9
	adc   r23,     r25     ; Absolute sector address by adding Data address

	ldd   r0,      Z + 22  ; Current sector within cluster of file
	add   r20,     r0
	adc   r21,     r1
	adc   r22,     r1
	adc   r23,     r1      ; Current absolute sector of file

sdlib_get_sector_root16:

	movw  r24,     ZL
	ret



/*
** Returns currently selected sector of file.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
** r25:r24: Current sector, high
** r23:r22: Current sector, low
** Clobbers:
** r0, r1 (zero), r18, r19, r20, r21, Z
*/
.global FAT_Get_Sector
FAT_Get_Sector:

	rcall sdlib_get_sector
	movw  r24,     r22
	movw  r22,     r20
	ret



/*
** Loads currently selected sector of file into sector buffer
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
**     r24: SD read errors (SD_Read_Sector_Rt)
** Clobbers:
** r0, r1 (zero), r18, r19, r20, r21, r22, r23, r24, r25, X, Z
*/
.global FAT_Read_Sector
FAT_Read_Sector:

	rcall sdlib_get_sector
	rjmp  SD_Read_Sector_Rt



/*
** Moves sector pointer forward (supporting fragmentation).
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Outputs:
**     r24: Zero on success. Otherwise:
**          1: End of file or other error.
** Clobbers:
** r0, r1 (zero), r18, r19, r20, r21, r22, r23, r24, r25, X
** ZH: ZL:  =Input(r25:r24)
*/
.global FAT_Next_Sector
.global FAT_Next_Sector_Z
FAT_Next_Sector:

	movw  ZL,      r24

FAT_Next_Sector_Z:

	ldd   r22,     Z + 18  ; Current sector / cluster
	ldd   r23,     Z + 19
	ldd   r24,     Z + 20
	ldd   r25,     Z + 21
	ldd   r0,      Z + 0   ; If FAT16 root dir. current sector, simple increment
	sbrc  r0,      3
	rjmp  FAT_Next_Sector_root16

	ldd   r20,     Z + 22  ; Current sector within cluster of file
	inc   r20
	ldd   r21,     Z + 3   ; Cluster size in 512b sector units
	cpse  r20,     r21     ; Reached end of cluster?
	rjmp  FAT_Next_Sector_inclus

	; Fetch next cluster of the file

	rcall FAT_NS_next_lsl_r25_r22
	sbrc  r0,      2       ; Byte offset in FAT16 / FAT32
	rcall FAT_NS_next_lsl_r25_r22

	push  r22
	push  r23              ; Save for offset within sector

	mov   r20,     r23
	mov   r21,     r24
	mov   r22,     r25
	clr   r23
	lsr   r22
	ror   r21
	ror   r20              ; 512 byte sector address relative to FAT
	ldd   r24,     Z + 4
	ldd   r25,     Z + 5   ; FAT0 sector address
	clr   r1
	add   r20,     r24
	adc   r21,     r25
	adc   r22,     r1
	adc   r23,     r1      ; 512 byte absolute sector address
	movw  r24,     ZL
	push  ZL
	push  ZH
	rcall SD_Read_Sector_Rt
	pop   ZH
	pop   ZL               ; Z: Still the SD data structure

	pop   r21
	pop   r20              ; Restore for offset within sector

	cpi   r24,     0x00
	brne  FAT_Next_Sector_eof

	ldd   r0,      Z + 0   ; SD data structure: Flags
	ldd   XL,      Z + 1
	ldd   XH,      Z + 2   ; SD data structure: Sector buffer
	andi  r21,     0x01    ; r21:r20: Byte offset within sector
	add   XL,      r20
	adc   XH,      r21
	ld    r22,     X+
	ld    r23,     X+
	clr   r24
	clr   r25              ; Normally clear for FAT16
	ldi   r20,     0xFF
	sbrs  r0,      2
	rjmp  FAT_NS_next_16

	ld    r24,     X+
	ld    r25,     X+      ; 32 bit cluster ID
	cp    r24,     r20
	cpc   r25,     r20     ; FAT32 cluster high 16 bits not 0xFFFF: OK
	brne  FAT_NS_next_ret
FAT_NS_next_16:
	cpi   r22,     0xF0
	cpc   r23,     r20     ; FAT16 < 0xFFF0 or FAT32 < 0xFFFFFFF0: OK
	brcc  FAT_Next_Sector_eof

FAT_NS_next_ret:

	ldi   r20,     0x00
	std   Z + 22,  r20     ; Current sector starts from 0 in next cluster

FAT_Next_Sector_oksave:

	std   Z + 18,  r22
	std   Z + 19,  r23
	std   Z + 20,  r24
	std   Z + 21,  r25     ; Next sector / cluster stored

FAT_Next_Sector_ok:

	ldi   r24,     0x00

FAT_Next_Sector_ret:

	ldi   r25,     0x00
	ret

FAT_Next_Sector_eof:

	ldi   r24,     0x01
	rjmp  FAT_Next_Sector_ret

FAT_Next_Sector_inclus:

	std   Z + 22,  r20
	rjmp  FAT_Next_Sector_ok

FAT_Next_Sector_root16:

	subi  r22,     0xFF
	sbci  r23,     0xFF
	sbci  r24,     0xFF
	sbci  r25,     0xFF
	ldd   r18,     Z + 6   ; Data start 512 byte sector (it is after Root dir)
	ldd   r19,     Z + 7
	ldd   r20,     Z + 8
	ldd   r21,     Z + 9
	cp    r22,     r18
	cpc   r23,     r19
	cpc   r24,     r20
	cpc   r25,     r21
	brcc  FAT_Next_Sector_eof
	rjmp  FAT_Next_Sector_oksave

FAT_NS_next_lsl_r25_r22:

	lsl   r22
	rol   r23
	rol   r24
	rol   r25
	ret



/*
** Reset sector pointer.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Clobbers:
** r0
** ZH: ZL:  =Input(r25:r24)
*/
.global FAT_Reset_Sector
.global FAT_Reset_Sector_Z
FAT_Reset_Sector:

	movw  ZL,      r24

FAT_Reset_Sector_Z:

	ldd   r0,      Z + 14
	std   Z + 18,  r0
	ldd   r0,      Z + 15
	std   Z + 19,  r0
	ldd   r0,      Z + 16
	std   Z + 20,  r0
	ldd   r0,      Z + 17
	std   Z + 21,  r0      ; Copy first cluster of file into current
	clr   r0
	std   Z + 22,  r0      ; Zero current cluster within sector
	ret



/*
** Selects root directory for reading.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** Clobbers:
** r0, r20, r21, r22, r23
** ZH: ZL:  =Input(r25:r24)
*/
.global FAT_Select_Root
.global FAT_Select_Root_Z
FAT_Select_Root:

	movw  ZL,      r24

FAT_Select_Root_Z:

	ldd   r23,     Z + 0
	sbrs  r23,     2
	ori   r23,     0x08    ; FAT16 root directory will be read
	std   Z + 0,   r23
	ldd   r20,     Z + 10  ; Root directory cluster / sector
	ldd   r21,     Z + 11
	ldd   r22,     Z + 12
	ldd   r23,     Z + 13
	std   Z + 14,  r20
	rjmp  FAT_Select_Root_tail



/*
** Selects a start cluster for reading.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** r23:r22: Start cluster, high
** r21:r20: Start cluster, low
** Clobbers:
** r0, r20
** ZH: ZL:  =Input(r25:r24)
*/
.global FAT_Select_Cluster
.global FAT_Select_Cluster_Z
FAT_Select_Cluster:

	movw  ZL,      r24

FAT_Select_Cluster_Z:

	std   Z + 14,  r20
	ldd   r20,     Z + 0
	andi  r20,     0xF7    ; Normal read (not a FAT16 root dir.)
	std   Z + 0,   r20
FAT_Select_Root_tail:
	std   Z + 15,  r21
	std   Z + 16,  r22
	std   Z + 17,  r23
	rjmp  FAT_Reset_Sector



/*
** Returns a file's start cluster by file descriptor. Returns zero if the
** input region is not a valid file descriptor.
**
** Inputs:
** r25:r24: Pointer to SD data structure
** r23:r22: Pointer to 32 byte FAT file descriptor
** Outputs:
** r25:r24: Start cluster, high
** r23:r22: Start cluster, low
** Clobbers:
** r0
** XH: XL:  =Input(r25:r24)
** ZH: ZL:  =Input(r23:r22)
*/
.global FAT_Get_File_Cluster
.global FAT_Get_File_Cluster_XZ
FAT_Get_File_Cluster:

	movw  XL,      r24
	movw  ZL,      r22

FAT_Get_File_Cluster_XZ:

	ldd   r22,     Z + 0x1A
	ldd   r23,     Z + 0x1B
	ldd   r24,     Z + 0x14
	ldd   r25,     Z + 0x15  ; File start cluster (FAT32)
	ld    r0,      X
	sbrs  r0,      2       ; FAT16 (0): Only 16 bit start cluster
	ldi   r24,     0x00
	sbrs  r0,      2
	ldi   r25,     0x00
	ret
